\label{XQuery}
\subsubsection{XQuery}

%----------------------------------------------------------------------
\begin{slide}{8500}
\frametitle{XQuery Overview}
\begin{itemize}
\item High-level way of working with XML
\item Is to \iConcept{XML} what \iConcept{SQL} is to databases
\begin{itemize}
\item Read data from \iConcept{XML}
\item Filter and sort the data
\item Write the result to a new \iConcept{XML} document
\end{itemize}
\item W3C recommendation.
\end{itemize}
\end{slide}


%----------------------------------------------------------------------

\begin{slide}[fragile]{0721}
\frametitle{XQuery Overview Cont'd.} \label{xquery-language}
\begin{itemize}
\item The important elements of the language are:
\begin{itemize}
\item \textbf{XPath expressions}
\item \textbf{FLWOR expressions}
\item \textbf{Node constructors}
\end{itemize}
\end{itemize}
\end{slide}

%----------------------------------------------------------------------

\begin{slide}[fragile]{0722}
\frametitle{\iConcept{XQuery} - Expressions}
\begin{itemize}
\item The language is based on expressions.
\item They can be as simple as "$<$newNode/$>$"
\item Complex expressions are written into curly braces:
\begin{xml}
 <html xmlns="http://www.w3.org/1999/xhtml/"
 xml:id="{doc('other.html')/html/attribute(xml:id)}"/> 
\end{xml}
\item The above example copies the \iConcept{XML} Id from other.html to the new html.
\end{itemize}
\demo{qtxmlpatterns/ex-queries/copy}
\end{slide}

%----------------------------------------------------------------------

\begin{slide}[fragile]{0723}
\frametitle{\iConcept{XQuery} - FLWOR Expressions}
\begin{itemize}
\item FLWOR expressions are similar to SELECT in SQL.
\item Used to iterate through the data, sort, and filter it and generate a new set of data from the result.
\item Examples:
\begin{itemize}
\item \textbf{for \$x in /artists/artist} - generates a list of bindings of \$x to each artist element in artists
\item \textbf{let \$x := value} - assigns a value to \$x
\item \textbf{order} - sorts the list by a given criteria
\item \textbf{where} - filters the list generated by for
\item \textbf{return} - constructs a resulting value for each tuple
\end{itemize}
\end{itemize}
\demo{qtxmlpatterns/ex-queries/collection}
\end{slide}

%----------------------------------------------------------------------

\begin{slide}[fragile]{0724}
\frametitle{\iConcept{XQuery} - FLWOR Expressions}
\begin{columns}
\begin{column}{40mm}
\begin{xml}
<album>
 <year>1971</year>
 <title>Imagine</title>
 <artistRef>1</artistRef>
</album>
...
<artists>
  <artist id ="1">
    John Lennon
  </artist>
 ...
</artists>  
\end{xml}        
\end{column}
\begin{column}{60mm}

\begin{xml}
let $doc := doc('collection.xml')
for $a in $doc//album,
    $s in $doc//artists/artist
where ends-with($s, 'Lennon')
and $a/artistRef = $s/attribute(id)
order by $a/year
return  
 <album name='{$a/title}' 
               year='{$a/year}'/>
\end{xml}
\end{column}
\end{columns}
\medskip
\textbf{Output:} \verb!<album name="Imagine" year="1971"/>! \ldots
\end{slide}
%$ This line is only to unconfuse the highlighting in XEmacs


%----------------------------------------------------------------------
\begin{slide}[fragile]{0733}
\frametitle{\iConcept{XQuery} - Creating Nodes}
\begin{itemize}
\item There is a simple way to create a new node that will be written to the result data:
\begin{xml}
<myNode />
\end{xml}
\item Any valid \iConcept{XML} code is a valid \iConcept{XQuery} expression.
\item It is possible to include expressions in curly braces:
\begin{xml}
<e>{sum(1,2)}</e> - creates: <e>3</e>
   or
declare variable $myClass := "example";
<p class="{$myClass}"/> - creates <p class="example"/>
\end{xml}
\item  The node constructors are also expressions:
\begin{xml}
doc('example.xml')//p/<para>{./node()}</para>
\end{xml}
\item The example creates a \textit{$<$para$>$} element for each \textit{$<$p$>$} and copies their children into it.
\end{itemize}
\end{slide}

%----------------------------------------------------------------------
\begin{slide}{0734}
\frametitle{\iConcept{XQuery} - Creating Nodes}
\begin{itemize}
\item Computed node constructors can be used to create node names at runtime.
\begin{itemize}
\item comment \{"My comment"\}
\item element \textit{name}
\item processing-instruction \textit{instruction}
\item text \{"My text"\}
\end{itemize}
\end{itemize}
\demo{qtxmlpatterns/ex-queries/create}
\end{slide}

%----------------------------------------------------------------------
\begin{slide}[fragile]{0735}
\frametitle{\iConcept{XQuery} - Creating Nodes}
\begin{columns}
  \begin{column}{50mm}
    \textbf{Query}
    \begin{xml}
element TopElement
{
  element SubElement
  {
    comment {"My comment"},
    processing-instruction
           target {"data"},
    element ThirdElement {()},
    text {"some text"}
  }
}      
    \end{xml}
  \end{column}
  \begin{column}{50mm}
   \textbf{Result}
   \begin{xml}
<TopElement>
  <SubElement>
    <!--My comment-->
    <?target data?>
    <ThirdElement/>
    some text
  </SubElement>
</TopElement>
     
   \end{xml}
  \end{column}
\end{columns}
\end{slide}

%----------------------------------------------------------------------
\begin{slide}{0736}\frametitle{\iConcept{XQuery} - Atomic Values}
\begin{itemize}
\item Atomic values are basic types that can be used as function arguments or return values:
\begin{itemize}
\item \textbf{xs:integer}: a 64 bit integer
\item \textbf{xs:boolean}: false or true
\item \textbf{xs:double}: a 64 bit floating point value
\item \textbf{xs:string}: a Unicode string 
\item \textbf{xs:date}: a date, like 2008-07-29
\item \textbf{xs:time}: a time, like 09:00:00
\item \textbf{xs:dateTime}: a date followed by a time: 2008-07-29T09:00:00
\item \textbf{xs:duration}: a time interval, like P5Y2M10DT15H, meaning 5 years, 2 months, 10 days and 15 hours.
\item \textbf{xs:base64Binary}: binary data in base64 encoding
\end{itemize}
\end{itemize}
\end{slide}


\subsection{QtXmlPatterns} \label{qtxmlpatterns}
%----------------------------------------------------------------------
\begin{slide}{0713}
\frametitle{XQuery in Qt}\label{xquery-qt}
\begin{itemize}
\item The XPath and XQuery-related classes can be found in the QtXmlPatterns module.
\item This module was introduced in Qt 4.4.
\item The QtXmlPatterns engine makes sure the data stored follows the \iConcept{XML} rules.
\item This means that the result of a query can be used by other software products.
\end{itemize}
\end{slide}


%----------------------------------------------------------------------
\begin{slide}[fragile]{0714}
\frametitle{XQuery in Qt}
\begin{itemize}
\item In order to use the XQuery classes from Qt, include:
\begin{itemize}
\item \texttt{\#include $<$QtXmlPattern$>$} - module include
\item \texttt{\#include $<$QtXmlPattern/QXmlQuery$>$} - more specific include
\end{itemize}
\item In the QMake .pro files add:
\begin{verbatim}
    QT += xmlpatterns
\end{verbatim}
\item \texttt{xmlpatterns} is a command line utility for easy testing of your \iConcept{XQuery} expressions.
\end{itemize}
\end{slide}


%----------------------------------------------------------------------
\begin{slide}{0715}
\frametitle{\iCls{QXmlQuery}}
\begin{itemize}
\item \iCls{QXmlQuery} executes queries in the \iConcept{XQuery} language
\item A query is added with \iClsFn{QXmlQuery}{setQuery} and evaluated with the \iClsFn{QXmlQuery}{evaluateTo} methods.
\item Queries can be evaluated to \iCls{QStringList}, \iCls{QXmlResultItems} or \iCls{QAbstractXmlReceiver}.
\item On the following slides, we will see how they are used.
\end{itemize}
\end{slide}


%----------------------------------------------------------------------
\begin{slide}[fragile]{0716}
\frametitle{Evaluating to \iCls{QStringList}}
\begin{itemize}
\item Evaluating to \iCls{QStringList} is possible only if the query evaluates to a sequence of string values.
\item Example:
\begin{cpp}
QXmlQuery query;
query.setQuery("doc('index.html')/html/body/p/string()");

QStringList result;
query.evaluateTo(&result);
\end{cpp}
\item The above example reads the text element from the paragraphs of index.html and puts the result into a \iCls{QStringList}.
% \item \highlight{THIS DOES NOT WORK CURRENTLY- BUGREPORT SENT TO TT}
\end{itemize}
\demo{qtxmlpatterns/ex-queries/qstringlist}
\end{slide}


%----------------------------------------------------------------------
\begin{slide}[fragile]{0717}
\frametitle{Evaluating to \iCls{QXmlResultItems}}
\begin{itemize}
\item \iCls{QXmlResultItems} is a sequence of \iCls{QXmlItem}s
\item A \iCls{QXmlItem} represents either a node or an atomic value.
\item A null item means it is invalid.
\item The query below evalutes to a node, an integer and a string:
\begin{cpp}
QXmlQuery query;
query.setQuery("<myNode />, 1, 'a string'");
QXmlResultItems result;
query.evaluateTo(&result);
QXmlItem item(result.next());
while (!item.isNull()) {
  // use item
  item = result.next();
}
\end{cpp}
\end{itemize}
\demo{qtxmlpatterns/ex-queries/qxmlresultitems}
\end{slide}


%----------------------------------------------------------------------
\begin{slide}{0718}
\frametitle{Evaluating to \iCls{QAbstractXmlReceiver}}
\begin{itemize}
\item \iCls{QAbstractXmlReceiver} is an abstract class, acting as a callback interface for query evaluation.
\item It can be used to transform the output of a \iCls{QXmlQuery}.
\item Its methods are called when an attibute, start/end element, comment, atomic value is found.
\item \iCls{QXmlSerializer} and \iCls{QXmlFormatter} are implementations of this interfaces and can be used to save the query result into an XML file.
\end{itemize}
\end{slide}


%----------------------------------------------------------------------
\begin{slide}[fragile]{0719}
\frametitle{Evaluating to \iCls{QXmlSerializer}}
\begin{itemize}
\item \iCls{QXmlSerializer}: translates an \iConcept{XQuery} sequence to \iConcept{XML} and writes the result into a \iCls{QIODevice}. 
\item Example, selecting the first paragraph from the html body:
\begin{cpp}
QXmlQuery query;
query.setQuery("doc('index.html')/html/body/p[1]");

QXmlSerializer serializer(query, myOutputDevice);
query.evaluateTo(&serializer);
\end{cpp}
\item The output is not formatted, for example:
\begin{verbatim}
<p><b>First</b> paragraph</p>
\end{verbatim}
\end{itemize}
\end{slide}


%----------------------------------------------------------------------
\begin{slide}[fragile]{0720}
\frametitle{Evaluating to \iCls{QXmlFormatter}}
\begin{itemize}
\item \iCls{QXmlFormatter} can be used to format the result of a query.
\item Usage example:
\begin{cpp}
QXmlQuery query;
query.setQuery("doc('index.html')/html/body/p[1]");

QXmlFormatter formatter(query, myOutputDevice);
formatter.setIndentationDepth(4);
query.evaluateTo(&formatter);
\end{cpp}
\item Example output with \iCls{QXmlFormatter}:
\begin{verbatim}
<p>
    <b>First</b> paragraph
</p>
\end{verbatim}
\end{itemize}
\demo{qtxmlpatterns/ex-queries/serializer}
\end{slide}
