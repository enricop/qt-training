%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright (c) 2008-2011, Nokia Corporation and/or its subsidiary(-ies).
% All rights reserved.
%
% This work, unless otherwise expressly stated, is licensed under a
% Creative Commons Attribution-ShareAlike 2.5.
%
% The full license document is available from
% http://creativecommons.org/licenses/by-sa/2.5/legalcode .
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Variants}

%----------------------------------------------------------------------
\begin{slide}[fragile]{0238}\frametitle{QVariant}
\begin{itemize}
  \item \iCls{QVariant} 
  \begin{itemize}
    \item Union for common Qt "value types" (copyable, assignable)
    \item Supports implicit sharing (fast copying)
    \item Supports user types
  \end{itemize}
  \item For \texttt{QtCore} types  
  \item[] \begin{cpp}
QVariant variant(42);
int value = variant.toInt(); // read back

qDebug() << variant.typeName(); // int
\end{cpp}
\item For non-core and custom types:
  \item[] \begin{cpp}
variant.setValue(QColor(Qt::red));
QColor color = variant.value<QColor>(); // read back
qDebug() << variant.typeName(); // "QColor"
\end{cpp}
\item \doc{qvariant.html\#details}{QVariant}
\end{itemize}
\end{slide}

%----------------------------------------------------------------------
\begin{slide}[fragile]{0240}
\frametitle{Q\_DECLARE\_METATYPE}
\begin{cpp}
// contact.h:
class Contact {
public:
  void setName(const QString name);
  QString name() const;
  ...
};
// make Contact known to meta-type system
Q_DECLARE_METATYPE(Contact);
\end{cpp} 
\begin{itemize}
\item Adds custom type to QVariant system.
\item Type must support default construction, copy and assignment.
\item Should appear after class definition in header file.
\doc{qmetatype.html\#Q_DECLARE_METATYPE}{Q\_DECLARE\_METATYPE}
\end{itemize}
\end{slide}

% ----------------------------------------------------------------------
\begin{slide}[fragile]{1254}
\frametitle{Custom Types and QVariant}

\begin{itemize}
    
\item Custom Type stored in \textbf{QVariant}:
\item[] \begin{cpp}
#include <QtGui> 
#include "contact.h"   // must have Q_DECLARE_METATYPE there

int main(int argc, argv) {
    QApplication app(argc, argv);
    // ... 
    Contact c; c.setName("Peter");
    QVariant v = QVariant::fromValue(c);
    Contact c2 = v.value<Contact>();    
    qDebug() << c2.name(); // "Peter"
    qDebug() << v.typeName();  // prints "Contact"    
    
\end{cpp}

\end{itemize}
\end{slide}

% ----------------------------------------------------------------------
\begin{slide}[fragile]{1253}
\frametitle{qRegisterMetaType}
\begin{itemize}
\item A \textbf{registered} type has a known string typename
\item Can be dynamically constructed with \texttt{construct()}
\item qRegisterMetaType() belongs in code, not header file.
\end{itemize}
\begin{cpp}
#include "contact.h"   // must have Q_DECLARE_METATYPE there
int main(int argc, argv) {
    QApplication app(argc, argv);
    
    // Register string typename:
    qRegisterMetaType<Contact>("Contact");
    
    Contact c;  c.setName("Peter");
    QVariant v = QVariant::variantValue(c);
    qDebug() << v.typeName();  // prints "Contact"
\end{cpp}
\doc{qmetatype.html\#qRegisterMetaType}{qRegisterMetaType}
\doc{qmetatype.html\#construct}{construct}
\end{slide}

% ----------------------------------------------------------------------
\subsubsection{Properties}
\begin{frame}[fragile]
\frametitle{Properties}
\begin{cpp}
    Q_PROPERTY( type name READ getFunction [WRITE setFunction]
    [RESET resetFunction] [NOTIFY notifySignal] [DESIGNABLE bool]
    [SCRIPTABLE bool] [STORED bool] )
\end{cpp}
\begin{itemize}
\item Macro for mapping property names to getter/setter functions
    \begin{itemize}
    \item optional - emit NOTIFY signals for change notification 
    \end{itemize}
\item An indirect way to call getters/setters of \texttt{QObject}s
    \begin{itemize}
    \item \texttt{property(char*)} calls a getter, returns value in \iCls{QVariant}
    \item \texttt{setProperty(char*, QVariant)} calls a setter
    \end{itemize}
\item Q\_OBJECT macro required for properties to work

\item If name is not declared as a \texttt{Q\_PROPERTY}
    \begin{itemize}
    \item store as \textbf{dynamic property} in \texttt{QObject}
    \item using \iCls{QVariantMap}  
    \end{itemize}
\item Class-reflection provided by \iCls{QMetaObject}, \iCls
{QMetaProperty}
    \begin{itemize}
    \item \texttt{QMetaObject} knows nothing about dynamic properties
    \end{itemize}
\end{itemize}
\end{frame}

% ----------------------------------------------------------------------
\begin{slide}[fragile]{1422}
\frametitle{QObject with Properties Example}
\begin{cpp}
class Customer : public QObject {
    Q_OBJECT  /* macro required for moc to preprocess class */

    Q_PROPERTY( QString id READ getId WRITE setId);
    Q_PROPERTY( QString name READ getName WRITE setName);
    Q_PROPERTY( QString address READ getAddress WRITE setAddress);
    // Read-only
    Q_PROPERTY( QDate dateEstablished READ getDateEstablished );
    Q_PROPERTY( CustomerType type READ getType WRITE setType);   
  public:
    enum CustomerType
    { Corporate, Individual, Educational, Government }; /* enum type
        must be in the same class as Q_ENUMS macro. */
    Q_ENUMS( CustomerType ) ;  /* generates string-to-enum
        conversion functions - also must be in same class */
\end{cpp}
\end{slide}

% ----------------------------------------------------------------------
\begin{slide}[fragile]{1423}
\frametitle{Using Properties}
\begin{itemize}
\item Direct vs indirect setting/getting:
\end{itemize}
\begin{cpp}
Customer cust;
cust.setProperty("name", QString("qt.nokia.com"));
cust.setAddress("54B East Middlesex Turnpike");
QVariant qv = cust.property("address");
Q_ASSERT(qv.toString() == cust.address());
Q_ASSERT(cust.name() == QString("qt.nokia.com"));
\end{cpp}
\end{slide}

% ----------------------------------------------------------------------
\begin{slide}[fragile]{1424}
\frametitle{Iterating through properties}                    
\begin{cpp}
QString objToString(const QObject* obj) {
    QStringList result;
    const QMetaObject *meta = obj->metaObject(); 
    result += QString("class %1 : public %2 {")
              .arg(meta->className())
              .arg(meta->superClass()->className());
    for (int i=0; i < meta->propertyCount(); ++i) {
        const QMetaProperty qmp = meta->property(i);
        QVariant value = obj->property(qmp.name());     
        result += QString("  %1 %2 = %3;")
            .arg(qmp.typeName()).arg(qmp.name())
            .arg(value.toString()); }
    result += "};";
    return result.join("\n");
}
\end{cpp}
\demo{coretypes/ex-properties}
\end{slide}

% ----------------------------------------------------------------------
\begin{slide}[fragile]{1425}
\frametitle{Example QObject with properties}
\begin{cpp}
int main (int argc, char* argv[]) {
    QApplication app(argc, argv);
    app.setOrganizationName("nokia");
    app.setApplicationName("testproperties");
    app.setOrganizationDomain("com");
    qDebug() << objToString(&app);
}
\end{cpp}
\demo{coretypes/ex-properties}
\end{slide}

% ----------------------------------------------------------------------
\begin{slide}[fragile]{1426}
\frametitle{Iterating through properties example}
\begin{cpp}
class QApplication : public QCoreApplication {
  QString objectName = ex-properties;
  QString applicationName = testproperties;
  QString applicationVersion = ;
  QString organizationName = nokia;
  QString organizationDomain = com;
  Qt::LayoutDirection layoutDirection = 0;
  int cursorFlashTime = 1000;
  int doubleClickInterval = 400;
  int keyboardInputInterval = 400;
  int wheelScrollLines = 3;
  int startDragTime = 500;
  int startDragDistance = 4;
  bool quitOnLastWindowClosed = true;
  QString styleSheet = ;
  bool autoSipEnabled = true;
};
\end{cpp}
\demo{coretypes/ex-properties}
\end{slide}
