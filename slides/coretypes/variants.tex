%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright (c) 2008-2011, Nokia Corporation and/or its subsidiary(-ies).
% All rights reserved.
%
% This work, unless otherwise expressly stated, is licensed under a
% Creative Commons Attribution-ShareAlike 2.5.
%
% The full license document is available from
% http://creativecommons.org/licenses/by-sa/2.5/legalcode .
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Variants}

%----------------------------------------------------------------------
\begin{slide}[fragile]{0238}\frametitle{QVariant}
\begin{itemize}
  \item \iCls{QVariant} 
  \begin{itemize}
    \item Union for common Qt "value types" (copyable, assignable)
    \item Supports implicit sharing (fast copying)
    \item Supports user types
  \end{itemize}\medskip
\item Use cases:
\end{itemize}
\begin{cpp}
QVariant property(const char* name) const;
void setProperty(const char* name, const QVariant &value);
\end{cpp}\medskip

\begin{cpp}
class QAbstractItemModel {
  virtual QVariant data( const QModelIndex& index, int role );
  ...
}
\end{cpp}
\end{slide}

%----------------------------------------------------------------------
\begin{slide}[fragile]{1020}\frametitle{QVariant}
\begin{itemize}
  \item For \texttt{QtCore} types  
  \item[] \begin{cpp}
QVariant variant(42);
int value = variant.toInt(); // read back
qDebug() << variant.typeName(); // int
\end{cpp}\vspace*{3mm}
\item For non-core and custom types:
  \item[] \begin{cpp}
QVariant variant = QVariant::fromValue(QColor(Qt::red));
QColor color = variant.value<QColor>(); // read back
qDebug() << variant.typeName(); // "QColor"
\end{cpp}\vspace*{3mm}
\item[] \doc{qvariant.html\#details}{QVariant}
\end{itemize}
\end{slide}

%----------------------------------------------------------------------
\begin{slide}[fragile]{0240}
\frametitle{Custom data types in variants}
\begin{itemize}
\item[]
\begin{cpp}
#include <QMetaType>

class Contact
{
  public:
    void setName(const QString & name);
    QString name() const;
  ...
};

Q_DECLARE_METATYPE(Contact);
\end{cpp}\medskip
\item Type must support default construction, copy and assignment.\medskip
\item Q\_DECLARE\_METATYPE shoud after class definition in header file.

\medskip
\doc{qmetatype.html\#Q_DECLARE_METATYPE}{Q\_DECLARE\_METATYPE}
\end{itemize}
\end{slide}

% ----------------------------------------------------------------------
\begin{slide}[fragile]{1254}
\frametitle{Custom Types and QVariant}

\begin{itemize}
\item[]
\begin{cpp}
#include "Contact.h"
#include <QDebug>
#include <QVariant>

int main(int argc, char* argv[])
{
    Contact contact;
    contact.setName("Peter");

    const QVariant variant = QVariant::fromValue(contact);

    const Contact otherContact = variant.value<Contact>();
    qDebug() << otherContact.name(); // "Peter"
    qDebug() << variant.typeName();  // prints "Contact"

    return 0;
}
\end{cpp}
\demo{coretypes/ex\_custom\_types}
\end{itemize}
\end{slide}

% ----------------------------------------------------------------------
\begin{slide}[fragile]{1253}
\frametitle{qRegisterMetaType}
\begin{itemize}
\item[]
\begin{cpp}
int main(int argc, char* argv[])
{
    // Register string typename:
    const int typeId = qRegisterMetaType<Contact>();

    Contact contact;
    contact.setName("Peter");

    // Create copy of object in a generic way
    void *object = QMetaType::construct(typeId, &contact);

    Contact *otherContact = reinterpret_cast<Contact*>(object);
    qDebug() << otherContact->name();

    return 0;
}
\end{cpp}
\doc{qmetatype.html\#qRegisterMetaType-2}{qRegisterMetaType}
\doc{qmetatype.html\#construct}{construct}
\end{itemize}
\end{slide}


% ----------------------------------------------------------------------
\subsubsection{Properties}
\begin{slide}[fragile]{1021}
\frametitle{Properties}
\begin{itemize}
\item Qt Quick example\\[2mm]
\begin{EXCLUDE}
Rectangle {
    objectName: "myRect"
    height: 100
    ...
}
\end{EXCLUDE}
\begin{qml}
\qtt{\qc{class}{Rectangle}~\{}\\
\qtt{~~~~\qc{type}{objectName}:~\qc{string}{"myRect"}}\\
\qtt{~~~~\qc{type}{height}:~\qc{number}{100}}\\
\qtt{~~~~...}\\
\qtt{\}}\\
\end{qml}\medskip

\item Direct access (Broken, due to private headers)
  \begin{cpp}
QQuickRectangle* rectangle
  = root->findChild<QQuickRectangle*>("myRect");
int height = rectangle->height();
  \end{cpp}\medskip

\item Generic property access:\\
\begin{cpp}
QObject* rectangle = root->findChild<QObject*>("myRect");
int height = rectangle->property("height").value<int>();
\end{cpp}
\end{itemize}
\hfill\tiny\textcolor{red}{Using findChild is almost always a bad idea!}
\end{slide}

% ----------------------------------------------------------------------
\begin{slide}[fragile]{1422}
\frametitle{Providing properties from QObject}
\begin{cpp}
class Customer : public QObject
{
    Q_OBJECT

    Q_PROPERTY(QString id READ getId WRITE setId NOTIFY idChanged);

  public:
     QString getId() const;
     void setId(const QString& id);
  
  signals:
     void idChanged();

  ...
};
\end{cpp}
\end{slide}

% ----------------------------------------------------------------------
\begin{slide}[fragile]{1022}
\frametitle{Enum properties}
\begin{cpp}
class Customer : public QObject
{
    Q_OBJECT

    Q_PROPERTY(CustomerType type READ getType WRITE setType 
               NOTIFY typeChanged);

  public:
    enum CustomerType {
      Corporate, Individual, Educational, Government
    };

    Q_ENUMS(CustomerType);
    
  ...
};
\end{cpp}
\end{slide}

% ----------------------------------------------------------------------
\begin{slide}[fragile]{2084}
\frametitle{Properties}
\begin{itemize}
  \item Q\_Property is a macro:
\begin{cpp}
  Q_PROPERTY( type name READ getFunction [WRITE setFunction]
  [RESET resetFunction] [NOTIFY notifySignal] [DESIGNABLE bool]
  [SCRIPTABLE bool] [STORED bool] )
\end{cpp}
  \medskip
  \item Property access methods:
\begin{cpp}
  QVariant property(const char* name) const;
  void setProperty(const char* name, const QVariant &value);
\end{cpp}
  \medskip
  \item If name is not declared as a \texttt{Q\_PROPERTY}
  \begin{itemize}
    \item -> \textbf{dynamic property}
    \item Not accessible from Qt Quick.
  \end{itemize}
  \medskip
  \item Note:
  \begin{itemize}
    \item Q\_OBJECT macro required for properties to work
    \item \texttt{QMetaObject} knows nothing about dynamic properties
  \end{itemize}
\end{itemize}
\end{slide}

% ----------------------------------------------------------------------
\begin{slide}[fragile]{1423}
\frametitle{Using Properties}
\begin{itemize}
\item \iCls{QMetaObject} support property introspection\smallskip
  \begin{cpp}
  const QMetaObject *metaObject = object->metaObject();
  const QString className = metaObject->className();
  const int propertyCount = metaObject->propertyCount();
  for ( int i=0; i<propertyCount; ++i ) {
    const QMetaProperty metaProperty = metaObject->property(i);
    const QString typeName = metaProperty.typeName()
    const QString propertyName = metaProperty.name();
    const QVariant value = object->property(metaProperty.name());
  }
  \end{cpp}
\end{itemize}
\demo{coretypes/ex-properties}
\end{slide}
