%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright (c) 2008-2011, Nokia Corporation and/or its subsidiary(-ies).
% All rights reserved.
%
% This work, unless otherwise expressly stated, is licensed under a
% Creative Commons Attribution-ShareAlike 2.5.
%
% The full license document is available from
% http://creativecommons.org/licenses/by-sa/2.5/legalcode .
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------
\subsection{Exporting Classes to QML}

%----------------------------------------------------------------------
\begin{slide}{1576}\frametitle{Overview}

Steps to define a new type in QML:

\begin{itemize}
\item In C++: Subclass either \iCls{QObject} or \iCls{QQuickItem}
\item In C++: Register the type with the QML environment
\item In QML: Import the module containing the new item
\item In QML: Use the item like any other standard item
\end{itemize}

\vspace*{0.5em}
\begin{itemize}
\item Non-visual types are \iCls{QObject} subclasses
\item Visual types (items) are \iCls{QQuickItem} subclasses
  \begin{itemize}
  \item \iCls{QQuickItem} is the C++ equivalent of \qic{class}{Item}
  \end{itemize}
\end{itemize}

\end{slide}

%----------------------------------------------------------------------

\subsubsection{Exporting Non-GUI Classes}

%----------------------------------------------------------------------

\begin{slide}[fragile]{8101}\frametitle{Step 1: Implementing the Class}

\begin{cpp}
#include <QObject>

class QTimer;

class Timer : public QObject
{
    Q_OBJECT
public:
    Timer(QObject *parent = 0);

private:
    QTimer* m_timer;
};
\end{cpp}
\end{slide}

%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Implementing the Class}
\begin{itemize}
\item \qtt{Timer} is a \iCls{QObject} subclass
\item As with all \iCls{QObject}s, each item can have a parent
\item Non-GUI custom items do not need to worry about any painting
\end{itemize}
\end{slide}

%----------------------------------------------------------------------

\begin{slide}[fragile]{8102}\frametitle{Step 1: Implementing the Class}
\begin{cpp}
#include "timer.h"
#include <QTimer>

Timer::Timer(QObject *parent)
    : QObject(parent),
      m_timer(new QTimer(this))
{
    m_timer->setInterval( 1000 );
    m_timer->start();
}
\end{cpp}
\end{slide}

%----------------------------------------------------------------------

\begin{slide}[fragile]{8103}\frametitle{Step 2: Registering the Class}

\begin{itemize}
\item[]
\begin{cpp}
#include <QGuiApplication>
#include <QQuickView>
#include "timer.h"

int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);
    qmlRegisterType<Timer>("CustomComponents", 1, 0, "Timer");

    QQuickView view;
    view.setSource(QUrl("qrc:/main.qml"));
    view.show();
    return app.exec();
}
\end{cpp}

\item Timer registered as an element in module "CustomComponents"
\item Automatically available to the \qtt{main.qml} file
\end{itemize}

\end{slide}

%----------------------------------------------------------------------

\begin{slide}[fragile]{1570}  \frametitle{Reviewing the Registration}

\begin{itemize}
\item[]
\begin{cpp}
qmlRegisterType<Timer>("CustomComponents", 1, 0, "Timer");
\end{cpp}

\item  This registers the \qtt{Timer} C++ class
\medskip
\item Available from the \qtt{CustomComponents} QML module
  \begin{itemize}
  \item version 1.0 (first number is major; second is minor)
  \end{itemize}
\item Available as the \qtt{Timer} element
  \begin{itemize}
  \item the \qtt{Timer} element is an non-visual item
  \item a subclass of \iCls{QObject}
  \end{itemize}
\end{itemize}
\end{slide}


%----------------------------------------------------------------------

\begin{slide}[fragile]{8104}\frametitle{Step 3+4 Importing and Using the Class}

In the \textit{main.qml} file:

\vspace*{0.5em}
\begin{qml}
\qtt{\qc{keyword}{import}~QtQuick~\qc{number}{2.0}}\\
\qtt{\qc{keyword}{import}~CustomComponents~\qc{number}{1.0}}\\
\vspace*{0.5em}
\qtt{\qc{class}{Rectangle}~\{}\\
\qtt{~~~~\qc{type}{width}:~\qc{number}{500}}\\
\qtt{~~~~\qc{type}{height}:~\qc{number}{360}}\\
\vspace*{0.5em}
\qtt{~~~~Timer~\{}\\
\qtt{~~~~~~~~\qc{type}{id}:~timer}\\
\qtt{~~~~~~~~...}\\
\vspace*{0.5em}
\qtt{~~~~\}}\\
\qtt{\}}\\
\end{qml}

\demo{qml-cpp-integration/ex\_simple\_timer}
\end{slide}
%----------------------------------------------------------------------

\begin{slide}{8108}\frametitle{Exercise: Review a more involving example}

  \begin{itemize}
  \item Review the example in \texttt{qml-cpp-integration/ex\_timer\_export}
  \item Discuss usage of:
    \begin{itemize}
    \item properties
    \item signals
    \item slots
    \item registrations
    \end{itemize}
  \end{itemize}
  \demo{qml-cpp-integration/ex\_timer\_export}
\end{slide}

%----------------------------------------------------------------------
\begin{slide}[fragile]\frametitle{Adding Properties}

In the \textit{main.qml} file:

\vspace*{0.5em}
\begin{qml}
\qtt{\qc{class}{Rectangle}~\{}\\
\qtt{~~~~...}\\
\vspace*{0.5em}
\qtt{~~~~\qc{class}{Timer}~\{}\\
\qtt{~~~~~~~~\qc{type}{id}:~timer}\\
\qtt{~~~~~~~~\qc{type}{interval}:~3000}\\
\qtt{~~~~\}}\\
\qtt{\}}\\
\end{qml}

\begin{itemize}
\item A new \qic{type}{interval} property

\item[] \demo{qml-cpp-integration/ex\_timer\_properties}
\end{itemize}

\end{slide}


%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Declaring a Property}

In the \textit{timer.h} file:

\vspace*{0.5em}
\begin{cpp}
class Timer : public QObject
{
    Q_OBJECT
    Q_PROPERTY( int interval READ interval 
                WRITE setInterval NOTIFY intervalChanged )
    ...
\end{cpp}
\begin{itemize}
\item Use a \iCls{Q\_PROPERTY} macro to define a new property
  \begin{itemize}
  \item named \qic{type}{interval} with \iCls{int} type
  \item with getter and setter, \hClsFn{Timer}{interval} and \hClsFn{Timer}{setInterval}
  \item emits the \hClsSig{Timer}{intervalChanged} signal when the value changes
  \end{itemize}
  \vspace*{0.5em}
\item The signal is just a notification
  \begin{itemize}
  \item it contains no value
  \item we must emit it to make property bindings work
  \end{itemize}
\end{itemize}

\end{slide}


%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Declaring Getter, Setter and Signal}

In the \textit{timer.h} file:
\vspace*{0.25em}
\begin{cpp}
public:
    ...
    void setInterval(int msec);
    int interval();

signals:
    void intervalChanged();
    ...

private:
    QTimer *m_timer;
};
\end{cpp}

\begin{itemize}
\item Declare the getter and setter
\item Declare the notifier signal
\item Contained QTimer object holds actual value
\end{itemize}

\end{slide}


%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Implementing Getter and Setter}

In the \textit{timer.cpp} file:
\vspace*{0.25em}
\begin{cpp}
void Timer::setInterval( int msec )
{
    if ( m_timer->interval() == msec )
        return;
    m_timer->stop();
    m_timer->setInterval( msec );
    m_timer->start();
    emit intervalChanged();
}

int Timer::interval()
{
    return m_timer->interval();
}
\end{cpp}

\begin{itemize}
\item Do not emit notifier signal if value does not actually change
\item Important to break cyclic dependencies in property bindings
\end{itemize}

\end{slide}


%----------------------------------------------------------------------

\begin{slide}\frametitle{Summary of Items and Properties}

\begin{itemize}
\item Register new QML types using \iCls{qmlRegisterType}
  \begin{itemize}
  \item new non-GUI types are subclasses of \iCls{QObject}
  \end{itemize}
\vspace*{0.5em}
\item Add QML properties
  \begin{itemize}
  \item define C++ properties with \qtt{NOTIFY} signals
  \item notifications are used to maintain the bindings between items
  \item \emph{only} emit notifier signals if value actually changes
  \end{itemize}
\end{itemize}

\end{slide} 





%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Adding Signals}

In the \textit{main.qml} file:

\begin{qml}
\vspace*{0.5em}
\qtt{\qc{class}{Rectangle}~\{}\\
\qtt{~~~~...}\\
\vspace*{0.5em}
\qtt{~~~~\qc{class}{Timer}~\{}\\
\qtt{~~~~~~~~\qc{type}{interval}:~\qc{number}{3000}}\\
\vspace*{0.5em}
\qtt{~~~~~~~~\qc{type}{onTimeout}:~\{}\\
\qtt{~~~~~~~~~~~~console.log(~\qc{string}{"Timer~fired!"}~);}\\
\qtt{~~~~~~~~\}}\\
\qtt{~~~~\}}\\
\qtt{\}}\\
\end{qml}

\begin{itemize}
\item A new \qic{type}{onTimeout} signal handler
  \begin{itemize}
  \item outputs a message to stderr.
  \end{itemize}
\end{itemize}

\demo{qml-cpp-integration/ex\_timer\_signals}
\end{slide}


%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Declaring a Signal}

In the \textit{timer.h} file:

\vspace*{0.5em}
\begin{cpp}
...
signals:
    void timeout();
    void intervalChanged();
...
\end{cpp}

\begin{itemize}
\item Add a \hClsSig{Timer}{timeout} signal
  \begin{itemize}
  \item this will have a corresponding \qic{type}{onTimeout} handler in QML
  \item we will emit this whenever the contained QTimer object fires
  \end{itemize}
\end{itemize}

\end{slide}


%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Emitting the Signal}

In the \textit{timer.cpp} file:

\vspace*{0.5em}
\begin{cpp}
Timer::Timer(QObject *parent)
    : QObject(parent),
      m_timer(new QTimer(this))
{
    connect(m_timer, SIGNAL(timeout()),
            this, SIGNAL(timeout()));
}
\end{cpp}

\begin{itemize}
\item Change the constructor
\item connect \hClsSig{QTimer}{QTimer::timeout} signal to \hClsSig{Timer}{Timer::timeout} signal
\end{itemize}

\end{slide}



%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Handling the Signal}

In the \textit{main.qml} file:

\begin{qml}
\vspace*{0.5em}
\qtt{\qc{class}{Rectangle}~\{}\\
\qtt{~~~~...}\\
\vspace*{0.5em}
\qtt{~~~~\qc{class}{Timer}~\{}\\
\qtt{~~~~~~~~\qc{type}{interval}:~\qc{number}{3000}}\\
\vspace*{0.5em}
\qtt{~~~~~~~~\qc{type}{onTimeout}:~\{}\\
\qtt{~~~~~~~~~~~~console.log(~\qc{string}{"Timer~fired!"}~);}\\
\qtt{~~~~~~~~\}}\\
\qtt{~~~~\}}\\
\qtt{\}}\\
\end{qml}

\begin{itemize}
\item In C++:
  \begin{itemize}
  \item the \iClsSig{QTimer}{timeout} signal is emitted
  \item connection means \iClsSig{Timer}{timeout} is emitted
  \end{itemize}
\item In QML:
  \begin{itemize}
  \item the \qic{class}{Timer} item's \qic{type}{onTimeout} handler is called
  \item outputs message to stderr
  \end{itemize}
\end{itemize}

\end{slide}


%----------------------------------------------------------------------

\begin{slide}\frametitle{Adding Methods to Items}

Two ways to add methods that can be called from QML:

\vspace*{0.5em}
\begin{enumerate}
\item Create C++ slots
  \begin{itemize}
  \item automatically exposed to QML
  \item useful for methods that do not return values
  \end{itemize}
\item Mark regular C++ functions as invokable
  \begin{itemize}
  \item allows values to be returned
  \end{itemize}
\end{enumerate}

\end{slide}


%----------------------------------------------------------------------
\begin{slide}[fragile]\frametitle{Adding Slots}

In the \textit{main.qml} file:

\vspace*{0.5em}
\begin{qml}
\qtt{\qc{class}{Rectangle}~\{}\\
\vspace*{0.5em}
\qtt{~~~~\qc{class}{Timer}~\{}\\
\qtt{~~~~~~~~\qc{type}{id}:~timer}\\
\qtt{~~~~~~~~\qc{type}{onTimeout}:~\{}\\
\qtt{~~~~~~~~~~~~console.log(~\qc{string}{"Timer~fired!"}~);}\\
\qtt{~~~~~~~~\}}\\
\qtt{~~~~\}}\\
\vspace*{0.5em}
\qtt{~~~~\qc{class}{MouseArea}~\{}\\
\vspace*{0.5em}
\qtt{~~~~~~~~\qc{type}{onClicked}:~\{}\\
\qtt{~~~~~~~~~~~~\qc{keyword}{if}~(~timer.active~\qc{operator}{==}~\qc{number}{false}~)~\{}\\
\qtt{~~~~~~~~~~~~~~~~timer.start();}\\
\qtt{~~~~~~~~~~~~\}~\qc{keyword}{else}~\{}\\
\qtt{~~~~~~~~~~~~~~~~timer.stop();}\\
\qtt{~~~~~~~~~~~~\}}\\
\qtt{~~~~~~~~\}}\\
\qtt{~~~~\}}\\
\qtt{\}}\\
\end{qml}
\end{slide}

%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Adding Slots}
\begin{itemize}
\item \qtt{Timer} now has \qtt{start()} and \qtt{stop()} methods
\item Normally, could just use properties to change state...
\item For example a \qic{type}{running} property
\end{itemize}

\demo{qml-cpp-integration/ex\_timer\_slots}

\end{slide}

%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Declaring Slots}

In the \textit{timer.h} file:

\vspace*{0.25em}
\begin{cpp}
...
public slots:
    void start();
    void stop();
...
\end{cpp}

\begin{itemize}
\item Added \hClsFn{Timer}{start} and \hClsFn{Timer}{stop} slots to public slots section
\item No difference to declaring slots in pure C++ application
\end{itemize}

\end{slide}


%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Implementing Slots}

In the \textit{timer.cpp} file:

\vspace*{0.25em}
\begin{cpp}
void Timer::start() {
    if ( m_timer->isActive() )
        return;
    m_timer->start();
    emit activeChanged();
}

void Timer::stop() {
    if ( !m_timer->isActive() )
        return;
    m_timer->stop();
    emit activeChanged();
}
\end{cpp}

\begin{itemize}
\item Remember to emit notifier signal for any changing properties
\end{itemize}

\end{slide}


%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Adding Methods}

In the \textit{main.qml} file:

\vspace*{0.5em}
\begin{qml}
\vspace*{0.5em}
\qtt{\qc{class}{Rectangle}~\{}\\
\vspace*{0.5em}
\qtt{~~~~\qc{class}{Timer}~\{}\\
\qtt{~~~~~~~~\qc{type}{id}:~timer}\\
\qtt{~~~~~~~~\qc{type}{interval}:~timer.randomInterval(~\qc{number}{500},~\qc{number}{1500}~)}\\
\vspace*{0.5em}
\qtt{~~~~~~~~\qc{type}{onTimeout}:~\{}\\
\qtt{~~~~~~~~~~~~console.log(~\qc{string}{"Timer~fired!"}~);}\\
\qtt{~~~~~~~~\}}\\
\qtt{~~~~\}}\\
\qtt{\}}\\
\end{qml}

\vspace*{0.5em}
\begin{itemize}
\item \qtt{Timer} now has a \qtt{randomInterval()} method
  \begin{itemize}
  \item obtain a random interval using this method
  \item accepts arguments for min and max intervals
  \item set the interval using the \qic{type}{interval} property
  \end{itemize}
\end{itemize}
\demo{qml-cpp-integration/ex-methods}

\end{slide}




%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Declaring a Method}

In the \textit{timer.h} file:

\vspace*{0.25em}
\begin{cpp}
...
public:
    explicit Timer( QObject* parent = 0 );
...
    Q_INVOKABLE int randomInterval( int min, int max ) const;
...
\end{cpp}

\begin{itemize}
\item Define the \hClsFn{Timer}{randomInterval} function
  \begin{itemize}
  \item add the \iCls{Q\_INVOKABLE} macro before the declaration
  \item returns an \iCls{int} value
  \item \textit{cannot} return a const reference
  \end{itemize}
\end{itemize}

\end{slide}


%----------------------------------------------------------------------

\begin{slide}[fragile]\frametitle{Implementing a Method}

In the \textit{timer.cpp} file:

\vspace*{0.5em}
\begin{cpp}
int Timer::randomInterval( int min, int max ) const
{
    int range = max - min;
    int msec = min + qrand() % range;
    qDebug() << "Random interval =" << msec << "msecs";
    return msec;
}
\end{cpp}

\begin{itemize}
\item Define the new \hClsFn{Timer}{randomInterval} function
  \begin{itemize}
  \item the pseudo-random number generator has already been seeded
  \item simply return an int
  \item do not use the \iCls{Q\_INVOKABLE} macro in the source file
  \end{itemize}
\end{itemize}

\end{slide}


%----------------------------------------------------------------------

\begin{slide}\frametitle{Summary of Signals, Slots and Methods}

\begin{itemize}
\item Define signals
  \begin{itemize}
  \item connect to Qt signals with the \qic{type}{onSignal} syntax
  \end{itemize}
\item Define QML-callable methods
  \begin{itemize}
  \item reuse slots as QML-callable methods
  \item methods that return values are marked using \iMacro{Q\_INVOKABLE}
  \end{itemize}
\end{itemize}

\end{slide}

%----------------------------------------------------------------------
\begin{slide}{1536}\frametitle{Creating Extension Plugins}

\begin{itemize}
\item Declarative extensions can be deployed as plugins 
  \begin{itemize}
  \item using source and header files for a working custom type
  \item developed separately then deployed with an application
  \item write QML-only components then rewrite in C++
  \item use placeholders for C++ components until they are ready
  \end{itemize}
\vspace*{0.5em}
\item Plugins can be loaded by the \qtt{qmlscene} tool
  \begin{itemize}
  \item with an appropriate \qtt{qmldir} file
  \end{itemize}
\vspace*{0.5em}
\item Plugins can be loaded by C++ applications
  \begin{itemize}
  \item some work is required to load and initialize them
  \end{itemize}
\end{itemize}

\end{slide}

%----------------------------------------------------------------------
\begin{slide}[fragile]{1535}\frametitle{Defining an Extension Plugin}

\begin{lstlisting}
#include <QQmlExtensionPlugin>

class EllipsePlugin : public QQmlExtensionPlugin
{
    Q_OBJECT
    Q_PLUGIN_METADATA(IID
      "org.qt-project.Qt.QQmlExtensionInterface/1.0")

public:
    void registerTypes(const char *uri);
};
\end{lstlisting}

\vspace*{0.5em}
\begin{itemize}
\item Create a \iCls{QQmlExtensionPlugin} subclass
  \begin{itemize}
  \item add type information for Qt's plugin system
  \item only one function to reimplement
  \end{itemize}
\end{itemize}

\end{slide}

%----------------------------------------------------------------------
\begin{slide}[fragile]{1534}\frametitle{Implementing an Extension Plugin}

\begin{lstlisting}
#include "ellipseplugin.h"
#include "ellipseitem.h"

void EllipsePlugin::registerTypes(const char *uri)
{
    qmlRegisterType<EllipseItem>(uri, 9, 0, "Ellipse");
}

\end{lstlisting}

\vspace*{0.5em}
\begin{itemize}
\item Register the custom type using the \qtt{uri} supplied
  \begin{itemize}
  \item the same custom type we started with
  \end{itemize}
\end{itemize}

\end{slide}

%----------------------------------------------------------------------
\begin{slide}[fragile]{1533}\frametitle{Building an Extension Plugin}

\begin{qmake}
TEMPLATE  = lib
CONFIG   += qt plugin
QT       += quick

HEADERS  += ellipseitem.h \
            ellipseplugin.h

SOURCES  += ellipseitem.cpp \
            ellipseplugin.cpp

DESTDIR   = ../plugins
\end{qmake}

\vspace*{0.5em}
\begin{itemize}
\item Ensure that the project is built as a Qt plugin
\item QtQuick module is added to the Qt configuration
\item Plugin is written to a \qtt{plugins} directory
\end{itemize}

\end{slide}

%----------------------------------------------------------------------
\begin{slide}[fragile]{1532}\frametitle{Using an Extension Plugin}

To use the plugin with the \qtt{qmlscene} tool:

\flushedImageDoubleWidth{qml-cpp-integration/images/plugin-location.pdf}
\begin{itemize}
\item Write a \qtt{qmldir} file
  \begin{itemize}
  \item include a line to describe the plugin
  \item stored in the \qtt{standalone} directory
  \end{itemize}
\vspace*{0.5em}
\item Write a QML file to show the item
  \begin{itemize}
  \item \qtt{ellipse9s.qml}
  \end{itemize}
\end{itemize}

\vspace*{1em}
The \qtt{qmldir} file contains a declaration:

\begin{alltt}
plugin ellipseplugin ../plugins
\end{alltt}

\begin{itemize}
\item \textbf{\qtt{plugin}} followed by
  \begin{itemize}
  \item the plugin name: \textbf{\qtt{ellipseplugin}}
  \item the plugin path relative to the \qtt{qmldir} file: \textbf{\qtt{../plugins}}
  \end{itemize}
\end{itemize}

\end{slide}

%----------------------------------------------------------------------
\begin{slide}[fragile]{1531}\frametitle{Using an Extension Plugin}

In the \qtt{ellipse9s.qml} file:

\vspace*{0.5em}
% qml-cpp-integration/ex-extension-plugin/standalone/ellipse9s.qml
\inputqml{qml-cpp-integration/colorized/ellipse9s}

\vspace*{0.5em}
\begin{itemize}
\item Use the custom item directly
\item No need to import any custom modules
  \begin{itemize}
  \item \qtt{qmldir} and \qtt{ellipse9s.qml} are in the same project
        directory
  \item \qtt{Ellipse} is automatically imported into the global namespace
  \end{itemize}
\end{itemize}

% uri mentioned but not explained

\end{slide}

%----------------------------------------------------------------------
\begin{slide}[fragile]{1530}\frametitle{Loading an Extension Plugin}

To load the plugin in a C++ application:

\begin{itemize}
\item Locate the plugin
  \begin{itemize}
  \item (perhaps scan the files in the \qtt{plugins} directory)
  \end{itemize}
\item Load the plugin with \iCls{QPluginLoader}
\begin{lstlisting}
QPluginLoader loader(pluginsDir.absoluteFilePath(fileName));
\end{lstlisting}
\vspace*{0.5em}
\item Cast the plugin object to a \iCls{QQmlExtensionPlugin}
\begin{lstlisting}
QQmlExtensionPlugin *plugin =
  qobject_cast<QQmlExtensionPlugin *>(loader.instance());
\end{lstlisting}
\vspace*{0.5em}
\item Register the extension with a URI
\begin{lstlisting}
if (plugin)
  plugin->registerTypes("Shapes");
\end{lstlisting}
  \begin{itemize}
  \item in this example, \qtt{Shapes} is used as a URI
  \end{itemize}
\end{itemize}

\end{slide}

%----------------------------------------------------------------------
\begin{slide}[fragile]{1529}\frametitle{Using an Extension Plugin}

In the \qtt{ellipse9s.qml} file:

\vspace*{0.5em}
% qml-cpp-integration/ex-extension-plugin/standalone/ellipse9.qml
\inputqml{qml-cpp-integration/colorized/ellipse9}

\begin{itemize}
\item The \qtt{Ellipse} item is part of the \qtt{Shapes} module
\item A different URI makes a different import necessary; e.g.,
\begin{lstlisting}
plugin->registerTypes("com.nokia.qt.examples.Shapes");
\end{lstlisting}
\item corresponds to\\
\begin{qml}
\qtt{\qc{keyword}{import}~com.nokia.qt.examples.Shapes~\qc{number}{9.0}}\\
\end{qml}
\end{itemize}

\end{slide}

%----------------------------------------------------------------------
\begin{slide}[fragile]{1528}\frametitle{Summary of Extension Plugins}

\begin{itemize}
\item Extensions can be compiled as plugins
  \begin{itemize}
  \item define and implement a \iCls{QQmlExtensionPlugin} subclass
  \item define the version of the plugin in the extension
  \item build a Qt plugin project with the \qtt{quick} option enabled
  \end{itemize}
\vspace*{0.5em}
\item Plugins can be loaded by the \qtt{qmlscene} tool
  \begin{itemize}
  \item write a \qtt{qmldir} file
  \item declare the plugin's name and location relative to the file
  \item no need to import the plugin in QML
  \end{itemize}
\vspace*{0.5em}
\item Plugins can be loaded by C++ applications
  \begin{itemize}
  \item use \iCls{QPluginLoader} to load the plugin
  \item register the custom types with a specific URI
  \item import the same URI and plugin version number in QML
  \end{itemize}
\end{itemize}

\end{slide}
